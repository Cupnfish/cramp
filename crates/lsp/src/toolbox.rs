use crate::converters::*;
use crate::error::{ToolResult, ToolboxError};
use crate::fs_utils::*;
use crate::models::*;
use crate::server::RaServer;
use dashmap::DashMap;
use itertools::Itertools;
use log::{debug, error, info, warn};
// *** Add find_symbol_by_name_in_hierarchy import
use lsp_types::{
    DocumentSymbol, Location, OneOf, Range, SymbolInformation, WorkspaceSymbolResponse,
};
use path_clean::PathClean;
use pathdiff::diff_paths;
use std::path::{Path, PathBuf};
use std::sync::Arc;
use tokio::sync::RwLock;
use tokio::time::{Duration, sleep};
use uuid::Uuid;

const MAX_INITIAL_DIAGNOSTICS: usize = 3;
const DEFAULT_FILE_TREE_MAX_ITEMS: usize = 100;
const DEFAULT_FILE_TREE_MAX_DEPTH: usize = 5;

/// The core orchestrator implementing the MCP tools.
#[derive(Debug, Default)]
pub struct Toolbox {
    servers: DashMap<String, Arc<RaServer>>,
    active_project: RwLock<Option<String>>,
    // Cache mapping generated fix_id -> WorkspaceEdit, generated by get_code_actions
    fix_cache: Arc<DashMap<String, CachedFix>>, // fix_id -> CachedFix
    // Cache for cargo check diagnostics, populated by list_diagnostics and manage_projects
    diagnostics_cache: Arc<DashMap<String, Vec<MyDiagnostic>>>, // project_name -> Vec<MyDiagnostic>
    request_timeout: Duration,
    shutdown_timeout: Duration,
    initial_wait: Duration,
}

impl Toolbox {
    pub fn new() -> Self {
        Self {
            servers: DashMap::new(),
            active_project: RwLock::new(None),
            fix_cache: Arc::new(DashMap::new()),
            diagnostics_cache: Arc::new(DashMap::new()),
            request_timeout: Duration::from_secs(210), // Default: 210s (was 90s + 2min)
            shutdown_timeout: Duration::from_secs(130), // Default: 130s (was 10s + 2min)
            initial_wait: Duration::from_secs(125),    // Default: 125s (was 5s + 2min)
        }
    }

    pub fn with_timeouts(request_timeout: u64, shutdown_timeout: u64, initial_wait: u64) -> Self {
        Self {
            servers: DashMap::new(),
            active_project: RwLock::new(None),
            fix_cache: Arc::new(DashMap::new()),
            diagnostics_cache: Arc::new(DashMap::new()),
            request_timeout: Duration::from_secs(request_timeout),
            shutdown_timeout: Duration::from_secs(shutdown_timeout),
            initial_wait: Duration::from_secs(initial_wait),
        }
    }

    /// Get a reference to the servers map for interactive commands
    pub fn servers(&self) -> &DashMap<String, Arc<RaServer>> {
        &self.servers
    }

    /// Add a new server to the servers map
    pub async fn add_server(&self, name: String, path: PathBuf) -> ToolResult<String> {
        if self.servers.contains_key(&name) {
            return Err(ToolboxError::Other(format!("Project '{}' already exists", name)));
        }
        
        let server = RaServer::start_with_timeouts(
            &path,
            name.clone(),
            self.request_timeout,
            self.shutdown_timeout,
            self.initial_wait,
        )
        .await
        .map_err(ToolboxError::ServerError)?;
        
        self.servers.insert(name.clone(), server);
        Ok(format!("Successfully added project '{}'", name))
    }

    /// Remove a server from the servers map
    pub async fn remove_server(&self, name: &str) -> ToolResult<String> {
        if let Some((_, server)) = self.servers.remove(name) {
            server.shutdown().await.map_err(ToolboxError::ServerError)?;
            self.clear_all_cache_for_project(name);
            
            // Clear active project if it was the removed one
            let mut active = self.active_project.write().await;
            if active.as_ref() == Some(&name.to_string()) {
                *active = None;
            }
            
            Ok(format!("Successfully removed project '{}'", name))
        } else {
            Err(ToolboxError::ProjectNotFound(name.to_string()))
        }
    }

    /// Set the active project
    pub async fn set_active_project(&self, name: &str) -> ToolResult<String> {
        if !self.servers.contains_key(name) {
            return Err(ToolboxError::ProjectNotFound(name.to_string()));
        }
        
        *self.active_project.write().await = Some(name.to_string());
        self.clear_all_cache_for_project(name);
        Ok(format!("Successfully set active project to '{}'", name))
    }

    /// List all projects
    pub async fn list_projects(&self) -> ToolResult<String> {
        let active = self.active_project.read().await;
        let mut result = String::new();
        
        if self.servers.is_empty() {
            result.push_str("No projects loaded.\n");
        } else {
            result.push_str("Loaded projects:\n");
            for entry in self.servers.iter() {
                let name = entry.key();
                let server = entry.value();
                let is_active = active.as_ref() == Some(name);
                let status = if is_active { " (active)" } else { "" };
                result.push_str(&format!("  - {}: {}{}\n", name, server.root_path().display(), status));
            }
        }
        
        if let Some(active_name) = active.as_ref() {
            result.push_str(&format!("\nActive project: {}\n", active_name));
        } else {
            result.push_str("\nNo active project set.\n");
        }
        
        Ok(result)
    }
    // --- Internal Helpers ---

    async fn get_active_server(&self) -> ToolResult<(String, Arc<RaServer>)> {
        let lock = self.active_project.read().await;
        let name = lock.as_ref().ok_or(ToolboxError::NoActiveProject)?;
        let server = self
            .servers
            .get(name)
            .map(|r| r.value().clone())
            .ok_or_else(|| {
                error!("Active project '{}' not found in server map!", name);
                ToolboxError::ProjectNotFound(name.clone())
            })?;
        Ok((name.clone(), server))
    }

    fn get_relative_path(&self, server: &RaServer, absolute_path: &Path) -> String {
        diff_paths(absolute_path, server.root_path())
            .unwrap_or_else(|| absolute_path.to_path_buf()) // Fallback
            .display()
            .to_string()
    }

    async fn validate_and_resolve_path(
        &self,
        relative_path_str: &str,
    ) -> ToolResult<(Arc<RaServer>, PathBuf, String)> {
        let (_, server) = self.get_active_server().await?;
        let root = server.root_path().clean();
        let proposed_path = root.join(relative_path_str).clean();

        // Security & Correctness: Must exist and be strictly within project root
        if !proposed_path.exists() || !proposed_path.starts_with(&root) {
            warn!(
                "Invalid or out-of-bounds path access attempt: root={:?}, requested='{}', resolved={:?}",
                root, relative_path_str, proposed_path
            );
            return Err(ToolboxError::InvalidPath(PathBuf::from(relative_path_str)));
        }
        let absolute = proposed_path.canonicalize().unwrap_or(proposed_path);
        Ok((server, absolute, relative_path_str.to_string()))
    }

    // Clears both fix and diagnostic cache for a project.
    fn clear_all_cache_for_project(&self, project_name: &str) {
        let initial_fix_count = self.fix_cache.len();
        self.fix_cache.retain(|_, v| v.project_name != project_name);
        let final_fix_count = self.fix_cache.len();
        if initial_fix_count > final_fix_count {
            debug!(
                "Cleared {} cached fixes for project '{}'",
                initial_fix_count - final_fix_count,
                project_name
            );
        }
        if self.diagnostics_cache.remove(project_name).is_some() {
            debug!("Cleared cached diagnostics for project '{}'", project_name);
        };
    }

    // Helper to run cargo check and update cache
    async fn run_check_and_cache(
        &self,
        name: &str,
        server: Arc<RaServer>,
    ) -> ToolResult<Vec<MyDiagnostic>> {
        info!("[{}] Running cargo check...", name);
        // Clear fixes, as new diagnostics invalidate old fixes
        self.fix_cache.retain(|_, v| v.project_name != name);

        let diags_0based: Vec<MyDiagnostic> =
            tokio::task::spawn_blocking(move || server.get_cargo_check_diagnostics())
                .await
                .map_err(ToolboxError::TaskJoin)?
                .map_err(ToolboxError::ServerError)?;

        info!(
            "[{}] Cargo check found {} diagnostics.",
            name,
            diags_0based.len()
        );
        self.diagnostics_cache
            .insert(name.to_string(), diags_0based.clone());
        Ok(diags_0based)
    }

    // =======================================
    // --- MCP Tool Implementations ---
    // =======================================

    // --- Tool 1: manage_projects ---
    pub async fn manage_projects(
        &self,
        path_or_name: Option<String>,
        remove_name: Option<String>,
    ) -> ToolResult<String> {
        let mut report = Vec::new();
        let mut next_step = "Review the workspace status.";
        let mut activated_project: Option<(String, Arc<RaServer>)> = None;

        // Handle removal first
        if let Some(to_remove) = remove_name {
            if let Some((_, server_to_remove)) = self.servers.remove(&to_remove) {
                info!("Shutting down and removing project: {}", to_remove);
                report.push(format!("Info: Shutting down project '{}'...", to_remove));
                server_to_remove
                    .shutdown()
                    .await
                    .map_err(ToolboxError::ServerError)?;
                report.push(format!("Success: Removed project '{}'.", to_remove));
                self.clear_all_cache_for_project(&to_remove);
                let mut active = self.active_project.write().await;
                if active.as_ref() == Some(&to_remove) {
                    info!(
                        "Clearing active project status as '{}' was removed.",
                        to_remove
                    );
                    *active = None;
                }
            } else {
                warn!("Project '{}' not found for removal.", to_remove);
                report.push(format!(
                    "Warning: Project '{}' not found for removal.",
                    to_remove
                ));
            }
        }

        // Handle add/select
        if let Some(input) = path_or_name {
            if let Some(server_ref) = self.servers.get(&input) {
                // Input matches an existing project name: SELECT it
                info!("Setting active project to existing: '{}'", input);
                let server = server_ref.value().clone();
                *self.active_project.write().await = Some(input.clone());
                report.push(format!("Success: Set active project to '{}'.", input));
                activated_project = Some((input.clone(), server));
                // Always clear cache when switching context
                self.clear_all_cache_for_project(&input);
            } else {
                // Input is not a known name: Assume it's a PATH and try LOADING
                let path = PathBuf::from(&input).clean();
                if !path.exists() {
                    error!("Path does not exist: {:?}", path);
                    return Err(ToolboxError::InvalidPath(path));
                }
                if !path.join("Cargo.toml").exists() {
                    error!("Path is not a cargo project: {:?}", path);
                    return Err(ToolboxError::NotACargoProject(path));
                }
                let name = path
                    .file_name()
                    .and_then(|s| s.to_str())
                    .unwrap_or("unnamed_project")
                    .to_string();

                // If project with this name (derived from path) already exists,
                // treat it as a selection of an existing project by its path's derived name.
                if let Some(existing_server_ref) = self.servers.get(&name) {
                    info!(
                        "Project with name '{}' (derived from path {:?}) already exists. Selecting it.",
                        name, path
                    );
                    let server = existing_server_ref.value().clone();
                    *self.active_project.write().await = Some(name.clone());
                    report.push(format!(
                        "Info: Project '{}' already loaded. Set as active project.",
                        name
                    ));
                    activated_project = Some((name.clone(), server));
                    self.clear_all_cache_for_project(&name); // Clear cache on selection
                } else {
                    info!("Loading new project '{}' from path: {:?}", name, path);
                    report.push(format!(
                        "Info: Loading project '{}' from {:?}...",
                        name, path
                    ));
                    report.push(
                        "Info: Initial project indexing may take a few moments...".to_string(),
                    );
                    let server_start_time = std::time::Instant::now();
                    let server = RaServer::start_with_timeouts(
                        &path,
                        name.clone(),
                        self.request_timeout,
                        self.shutdown_timeout,
                        self.initial_wait,
                    )
                    .await
                    .map_err(ToolboxError::ServerError)?;
                    let server_load_duration = server_start_time.elapsed();
                    report.push(format!(
                        "Info: Project '{}' indexed in {:.2?}.",
                        name, server_load_duration
                    ));

                    self.servers.insert(name.clone(), server.clone());
                    *self.active_project.write().await = Some(name.clone()); // Set as active
                    report.push(format!(
                        "Success: Loaded and set active project to '{}'.",
                        name
                    ));
                    activated_project = Some((name.clone(), server));
                    self.clear_all_cache_for_project(&name);
                }
            }
        }

        // --- Generate Snapshot for newly activated project ---
        let mut has_diagnostics = false;
        if let Some((name, server)) = activated_project {
            report.push("\n### Project Snapshot".to_string());
            // 1. File Tree
            report.push("--- File Tree ---".to_string());
            let root = server.root_path().to_path_buf();
            let tree_result = tokio::task::spawn_blocking(move || {
                get_file_tree_string(
                    &root,
                    Some(DEFAULT_FILE_TREE_MAX_ITEMS),
                    Some(DEFAULT_FILE_TREE_MAX_DEPTH),
                )
            })
            .await;
            match tree_result {
                Ok(Ok(tree)) => report.push(tree),
                Ok(Err(e)) => report.push(format!("Error generating file tree: {}", e)),
                Err(e) => report.push(format!("Error generating file tree (task): {}", e)),
            }

            // 2. Initial Diagnostics
            report.push("\n--- Initial Diagnostics Summary ---".to_string());
            match self.run_check_and_cache(&name, server.clone()).await {
                Ok(diags) => {
                    let error_and_warnings: Vec<_> = diags
                        .iter()
                        .filter(|d| matches!(d.severity, MySeverity::Error | MySeverity::Warning))
                        .collect();
                    let count = error_and_warnings.len();
                    has_diagnostics = count > 0;
                    report.push(format!("Total errors and warnings: {}", count));
                    if count > 0 {
                        report.push(format!(
                            "Showing first {}:",
                            std::cmp::min(count, MAX_INITIAL_DIAGNOSTICS)
                        ));
                        for diag in error_and_warnings.iter().take(MAX_INITIAL_DIAGNOSTICS) {
                            let rel_path = self.get_relative_path(&server, &diag.location.path);
                            report.push(format!(
                                "- {}:{}:{}: [{}] {}",
                                rel_path,
                                diag.location.range.start.line,
                                diag.location.range.start.column,
                                diag.severity,
                                diag.message.lines().next().unwrap_or("").trim() // first line only
                            ));
                        }
                    }
                }
                Err(e) => report.push(format!("Error running initial check: {}", e)),
            }
            // Set guidance based on activation
            next_step = if has_diagnostics {
                "Analyze the file tree and initial diagnostics. Use `list_diagnostics` for full details, `get_symbol_info` to understand code, or `get_code_actions` to find fixes."
            } else {
                "Project loaded with no initial errors. Use `test_project` to run tests, or `list_document_symbols`/`search_workspace_symbols` to explore the code."
            };
        }

        // --- Generate Final Status Report ---
        let active = self.active_project.read().await;
        let active_name = active.as_deref();
        report.push("\n### Workspace Status".to_string());
        if self.servers.is_empty() {
            report.push("- (empty)".to_string());
            next_step = "Use `manage_projects` with a path to load a project.";
        } else {
            for entry in self.servers.iter().sorted_by_key(|e| e.key().clone()) {
                let status = if Some(entry.key().as_str()) == active_name {
                    " (active)"
                } else {
                    ""
                };
                report.push(format!("- {}{}", entry.key(), status));
            }
        }
        if active_name.is_none() && !self.servers.is_empty() {
            next_step = "Use `manage_projects` with a project name to select an active project.";
        }
        report.push(format!("\n---\nNext Step: {}", next_step));
        Ok(report.join("\n"))
    }

    // --- Tool 2: list_diagnostics ---
    // *** PERFORMANCE: Add force_recheck and caching logic ***
    pub async fn list_diagnostics(
        &self,
        file_path: Option<String>,
        limit: Option<u32>,
        force_recheck: Option<bool>, // Add parameter
    ) -> ToolResult<String> {
        let (name, server) = self.get_active_server().await?;

        let force = force_recheck.unwrap_or(false);
        let all_diags =
            // Check cache first unless force is true
            if !force {
                if let Some(cached) = self.diagnostics_cache.get(&name) {
                    info!("[{}] Returning cached diagnostics ({}). Use force_recheck=true to update.", name, cached.len());
                    cached.value().clone()
                } else {
                    info!("[{}] No cache found, running check.", name);
                    self.run_check_and_cache(&name, server.clone()).await?
                }
            } else {
                info!("[{}] Force re-check requested.", name);
                self.run_check_and_cache(&name, server.clone()).await?
            };
        // *********************************************************

        let limit_usize = limit.map(|l| l as usize).unwrap_or(usize::MAX);
        let resolved_path = match &file_path {
            Some(p) => Some(self.validate_and_resolve_path(p).await?.1),
            None => None,
        };

        let filtered_diags: Vec<SimpleDiagnostic> = all_diags
            .iter()
            .filter(|d| matches!(d.severity, MySeverity::Error | MySeverity::Warning))
            .filter(|d| {
                resolved_path
                    .as_ref()
                    .map_or(true, |rp| rp == &d.location.path)
            })
            .take(limit_usize)
            .map(|diag| SimpleDiagnostic {
                severity: diag.severity.to_string(),
                message: diag.message.clone(),
                file_path: self.get_relative_path(&server, &diag.location.path),
                line: diag.location.range.start.line,
                column: diag.location.range.start.column,
            })
            .collect();

        let json_output = serde_json::to_string_pretty(&filtered_diags)?;
        // Add cache info to guidance
        let cache_status = if !force && self.diagnostics_cache.contains_key(&name) {
            "(cached)"
        } else {
            "(live check)"
        };
        let guidance = if filtered_diags.is_empty() {
            format!(
                "No errors or warnings found {}. Next: Run `test_project` or explore symbols.",
                cache_status
            )
        } else {
            format!(
                "Analyze the diagnostics {}. Next: Use `get_code_actions` with a file_path and message to find fixes, or `get_symbol_info` to understand the code at the error location. Use `force_recheck: true` to get fresh results.",
                cache_status
            )
        };
        Ok(format!(
            "{}

---
Next Step: {}",
            json_output, guidance
        ))
    }

    // --- Tool 3: get_code_actions ---
    pub async fn get_code_actions(
        &self,
        file_path: String,
        diagnostic_message: String,
    ) -> ToolResult<String> {
        let (name, server) = self.get_active_server().await?;
        let (_, abs_path, _) = self.validate_and_resolve_path(&file_path).await?;

        let cached_diags = self
            .diagnostics_cache
            .get(&name)
            .ok_or_else(|| ToolboxError::CacheEmpty(name.clone()))?;

        // Find the exact diagnostic in the cache
        let target_diag = cached_diags
            .iter()
            .find(|d| d.location.path == abs_path && d.message == diagnostic_message)
            .ok_or_else(|| {
                ToolboxError::DiagnosticNotFound(file_path.clone(), diagnostic_message.clone())
            })?;

        info!(
            "[{}] Querying code actions for diagnostic in {}",
            name, file_path
        );
        let mut actions_with_ids = Vec::new();

        // Query RA using the location from the cached diagnostic
        let actions = server
            .get_code_actions(&target_diag.location.path, target_diag.location.range)
            .await
            .map_err(ToolboxError::ServerError)?;

        for action in actions {
            if let Some(edit) = action.edit {
                let fix_id = Uuid::new_v4().to_string();
                let mut diff = "[Could not generate diff]".to_string();
                if let Ok(file_edits) = workspace_edit_to_file_edits(&edit) {
                    if let Some(first_edit) = file_edits.first() {
                        // Read file content asynchronously for diff
                        if let Ok(content) = tokio::fs::read_to_string(&first_edit.path).await {
                            diff = generate_diff_preview(&content, &first_edit.edits);
                        } else {
                            debug!(
                                "[{}] Could not read file {:?} for diff generation",
                                name, first_edit.path
                            );
                        }
                    }
                }
                // Cache the edit for potential apply_fix call
                self.fix_cache.insert(
                    fix_id.clone(),
                    CachedFix {
                        project_name: name.clone(),
                        edit,
                    },
                );
                actions_with_ids.push(ActionWithId {
                    id: fix_id,
                    description: action.title,
                    diff,
                });
            }
        }

        let json_output = serde_json::to_string_pretty(&actions_with_ids)?;
        let guidance = if actions_with_ids.is_empty() {
            "No automatic fixes found for this diagnostic. Next: Use `get_symbol_info` or `list_document_symbols` to understand the code and manually fix the issue."
        } else {
            "Review the available fixes and their diffs. Next: Use `apply_fix` with the chosen 'id'."
        };
        Ok(format!("{}\n\n---\nNext Step: {}", json_output, guidance))
    }

    // --- Tool 4: apply_fix ---
    pub async fn apply_fix(&self, fix_id: String) -> ToolResult<String> {
        let (name, server) = self.get_active_server().await?;

        let cached_fix = self
            .fix_cache
            .remove(&fix_id)
            .ok_or_else(|| ToolboxError::FixNotFound(fix_id.clone()))?
            .1;

        if cached_fix.project_name != name {
            warn!(
                "[{}] Attempted to apply fix {} belonging to project {}",
                name, fix_id, cached_fix.project_name
            );
            let error = ToolboxError::FixNotFound(format!(
                "{} (belongs to project {}, not active project {})",
                fix_id, cached_fix.project_name, name
            ));
            // IMPORTANT: Put it back in cache if it wasn't for this project!
            self.fix_cache.insert(fix_id.clone(), cached_fix);
            return Err(error);
        }

        // IMPORTANT: Applying ANY fix invalidates ALL other cached fixes AND diagnostics for this project
        self.clear_all_cache_for_project(&name);

        let file_edits = workspace_edit_to_file_edits(&cached_fix.edit)
            .map_err(|e| ToolboxError::ApplyEditFailed(format!("Conversion error: {}", e)))?;

        info!(
            "[{}] Applying fix {} across {} files",
            name,
            fix_id,
            file_edits.len()
        );
        for file_edit in file_edits {
            let path = file_edit.path.clone();
            let rel_path = self.get_relative_path(&server, &path);
            let server_clone = server.clone();
            debug!("[{}] Applying edits to {}", name, rel_path);
            let new_content = tokio::task::spawn_blocking(move || {
                apply_lsp_edits_to_file(&file_edit.path, &file_edit.edits)
            })
            .await??;

            // CRITICAL: Notify RA server about the file change on disk to sync VFS
            server_clone
                .notify_file_content(&path, &new_content)
                .await
                .map_err(|e| {
                    ToolboxError::ApplyEditFailed(format!(
                        "Notify RA failed for {}: {}",
                        rel_path, e
                    ))
                })?;
            sleep(Duration::from_millis(150)).await;
        }
        Ok(format!(
            "Success: Applied fix '{}'.\n\n---\nNext Step: Run 'list_diagnostics' again to verify the fix and check for new issues.",
            fix_id
        ))
    }

    // --- Tool 5: get_file_tree ---
    pub async fn get_file_tree(&self) -> ToolResult<String> {
        let (name, server) = self.get_active_server().await?;
        info!("[{}] Getting file tree", name);
        let root = server.root_path().to_path_buf();
        let tree = tokio::task::spawn_blocking(move || {
            get_file_tree_string(
                &root,
                Some(DEFAULT_FILE_TREE_MAX_ITEMS),
                Some(DEFAULT_FILE_TREE_MAX_DEPTH),
            )
        })
        .await??;
        Ok(format!(
            "{}\n\n---\nNext Step: Use this tree to identify relevant files. Use client-side I/O to read file content, `list_document_symbols` to explore a file's structure, or `list_diagnostics` to find issues.",
            tree
        ))
    }

    // --- Tool 6: list_document_symbols ---
    pub async fn list_document_symbols(&self, file_path: String) -> ToolResult<String> {
        let (name, server) = self.get_active_server().await?;
        let (_, abs_path, _) = self.validate_and_resolve_path(&file_path).await?;
        info!("[{}] Listing symbols for {}", name, file_path);

        let symbols = server
            .list_document_symbols(&abs_path)
            .await
            .map_err(ToolboxError::ServerError)?;
        let mut flat_symbols = Vec::new();
        let server_clone = server.clone();
        // Use a closure to capture self and server for the helper
        let get_rel = |p: &Path| self.get_relative_path(&server_clone, p);
        flatten_document_symbols(&symbols, abs_path, &mut flat_symbols, &get_rel);

        let json_output = serde_json::to_string_pretty(&flat_symbols)?;
        let guidance = "Review the symbols. Next: Use `get_symbol_info` with file_path, line, and column to get details about a specific symbol.";
        Ok(format!("{}\n\n---\nNext Step: {}", json_output, guidance))
    }

    // --- Tool 7: get_symbol_info ---
    // *** USABILITY: Redesign parameter logic ***
    pub async fn get_symbol_info(
        &self,
        file_path: String,
        line: Option<u32>,           // Make Optional
        column: Option<u32>,         // Make Optional
        symbol_name: Option<String>, // Add parameter
    ) -> ToolResult<String> {
        let (name, server) = self.get_active_server().await?;
        let (_, abs_path, _) = self.validate_and_resolve_path(&file_path).await?;

        let target_pos: Option<Position>;
        let mut symbol_not_found_msg = None;

        match (line, column, &symbol_name) {
            // Case 1: Position-based lookup
            (Some(l), Some(c), _) => {
                info!(
                    "[{}] Getting symbol info for {}:{}:{} (by position)",
                    name, file_path, l, c
                );
                target_pos = Some(Position { line: l, column: c });
            },
            // Case 2: Name-based lookup
            (None, None, Some(sym_name)) => {
                info!(
                    "[{}] Getting symbol info for '{}' in {} (by name)",
                    name, sym_name, file_path
                );
                // Find the symbol definition within this document
                let symbols: Vec<DocumentSymbol> = server
                    .list_document_symbols(&abs_path)
                    .await
                    .map_err(ToolboxError::ServerError)?;

                if let Some(found_symbol) = find_symbol_by_name_in_hierarchy(&symbols, sym_name) {
                    // Use the start of the symbol's selection range as the target position
                    target_pos = Some(lsp_position_to_my(&found_symbol.selection_range.start));
                    debug!("[{}] Found symbol '{}' at {:?}", name, sym_name, target_pos);
                } else {
                    // Symbol name not defined in this file
                    target_pos = None;
                    symbol_not_found_msg = Some(format!(
                        "Info: Symbol definition '{}' not found in file '{}'.\nIt might be defined elsewhere, or the name is incorrect.\n\n---\nNext Step: Use `search_workspace_symbols` to find the definition file, or provide line/column of the symbol's *usage* in this file.",
                        sym_name, file_path
                    ));
                }
            },
            // Case 3: Invalid parameters
            _ => return Err(ToolboxError::Other("Invalid parameters for get_symbol_info: Provide EITHER both 'line' and 'column', OR 'symbol_name'.".into())),
        }

        // If name lookup failed, return the specific message
        if let Some(msg) = symbol_not_found_msg {
            return Ok(msg);
        }
        // If no position could be determined (should only happen if name lookup failed, handled above, but check anyway)
        let pos = match target_pos {
            Some(p) => p,
            None => {
                return Ok(format!(
                    // Fallback
                    "Info: Could not determine position for symbol in {}.\n\n---\nNext Step: Verify parameters.",
                    file_path
                ));
            }
        };

        // get_api_structure uses goto-definition internally, so it works whether
        // `pos` points to the definition itself (from name lookup)
        // or just a usage (from line/col lookup).
        let api_info_opt = server
            .get_api_structure(&abs_path, pos)
            .await
            .map_err(ToolboxError::ServerError)?;

        let guidance = "Analyze the symbol details. Next: Use this information to understand diagnostics or plan code modifications.";
        match api_info_opt {
            Some(api_info) => {
                let summary = api_info_to_summary(&api_info);
                Ok(format!(
                    "{}

---
Next Step: {}",
                    summary, guidance
                ))
            }
            None => Ok(format!(
                // Message reflects uncertainty of input method
                "Info: No detailed symbol information or definition found for the symbol at or named near {}:{}:{}{:?}.\n\n---\nNext Step: {}",
                file_path,
                line.unwrap_or(pos.line),
                column.unwrap_or(pos.column),
                symbol_name.as_deref().unwrap_or(""),
                guidance
            )),
        }
    }
    // ******************************************

    // --- Tool 8: search_workspace_symbols ---
    pub async fn search_workspace_symbols(&self, query: String) -> ToolResult<String> {
        let (name, server) = self.get_active_server().await?;
        info!("[{}] Searching workspace symbols for '{}'", name, query);
        if query.trim().is_empty() {
            return Err(ToolboxError::Other("Search query cannot be empty".into()));
        }

        let symbols_response = server
            .search_workspace_symbols(&query)
            .await
            .map_err(ToolboxError::ServerError)?;

        let symbols = match symbols_response {
            Some(WorkspaceSymbolResponse::Flat(symbols)) => symbols,
            Some(WorkspaceSymbolResponse::Nested(workspace_symbols)) => {
                // Convert WorkspaceSymbol to SymbolInformation
                workspace_symbols
                    .into_iter()
                    .map(|ws| {
                        let location = match ws.location {
                            OneOf::Left(location) => location,
                            OneOf::Right(workspace_location) => {
                                // Convert WorkspaceLocation to Location with empty range
                                Location {
                                    uri: workspace_location.uri,
                                    range: Range {
                                        start: lsp_types::Position {
                                            line: 0,
                                            character: 0,
                                        },
                                        end: lsp_types::Position {
                                            line: 0,
                                            character: 0,
                                        },
                                    },
                                }
                            }
                        };
                        SymbolInformation {
                            name: ws.name,
                            kind: ws.kind,
                            tags: ws.tags,
                            #[allow(deprecated)]
                            deprecated: None,
                            location,
                            container_name: ws.container_name,
                        }
                    })
                    .collect()
            }
            None => Vec::new(),
        };

        let server_clone = server.clone();
        let get_rel = |p: &Path| self.get_relative_path(&server_clone, p);
        let flat_symbols = workspace_symbols_to_flat(&symbols, &get_rel)
            .map_err(|e| ToolboxError::Other(format!("Symbol conversion error: {}", e)))?;

        let json_output = serde_json::to_string_pretty(&flat_symbols)?;
        let guidance = "Review the search results. Next: Use `get_symbol_info` with file_path, line, and column to get details about a specific symbol.";
        Ok(format!("{}\n\n---\nNext Step: {}", json_output, guidance))
    }

    // --- Tool 9: test_project ---
    pub async fn test_project(&self, test_name: Option<String>) -> ToolResult<String> {
        let (name, server) = self.get_active_server().await?;
        info!("[{}] Running tests (filter: {:?})...", name, test_name);
        // Tests might change state or rely on diagnostics, clear cache.
        self.clear_all_cache_for_project(&name);

        let server_clone = server.clone();
        let output: CargoTestOutput =
            tokio::task::spawn_blocking(move || server_clone.run_cargo_test(test_name.as_deref()))
                .await??;

        let guidance = if output.success {
            info!("[{}] Tests passed.", name);
            "All tests passed. The task is likely complete."
        } else {
            warn!("[{}] Tests failed.", name);
            "Tests failed. Analyze the output. Use `list_diagnostics`, `get_symbol_info`, or client-side file reading to understand the issue, then fix using `apply_fix` or manual edits."
        };
        let report = if output.success {
            output.stdout
        } else {
            format!(
                "--- STDOUT ---\n{}\n--- STDERR ---\n{}",
                output.stdout, output.stderr
            )
        };
        Ok(format!("{}\n\n---\nNext Step: {}", report, guidance))
    }

    /// Gracefully shuts down all managed RaServer instances.
    pub async fn shutdown_all(&self) -> ToolResult<()> {
        info!("Toolbox shutting down all managed servers...");
        let keys: Vec<_> = self.servers.iter().map(|s| s.key().clone()).collect();
        info!("Found {} servers to shut down.", keys.len());
        for key in keys {
            if let Some((_, server)) = self.servers.remove(&key) {
                info!("Shutting down server for project: {}", key);
                server.shutdown().await.map_err(ToolboxError::ServerError)?;
                self.clear_all_cache_for_project(&key);
            }
        }
        self.fix_cache.clear();
        self.diagnostics_cache.clear();
        *self.active_project.write().await = None;
        info!("Toolbox shutdown complete.");
        Ok(())
    }
}
