use crate::converters::*;
use crate::error::{ToolResult, ToolboxError};
use crate::fs_utils::*;
use crate::models::*;
use crate::server::RaServer;
use dashmap::DashMap;

use log::{debug, error, info, warn};
// *** Add find_symbol_by_name_in_hierarchy import
use lsp_types::{Location, OneOf, Range, SymbolInformation, WorkspaceSymbolResponse};
use path_clean::PathClean;
use pathdiff::diff_paths;
use rayon::iter::IntoParallelRefIterator as _;
use rayon::iter::ParallelIterator as _;
use rayon::iter::{IndexedParallelIterator as _, IntoParallelIterator};
use std::path::{Path, PathBuf};
use std::sync::Arc;
use strsim::jaro_winkler;
use tokio::sync::RwLock;
use tokio::task::spawn_blocking;
use tokio::time::{Duration, sleep};
use uuid::Uuid;

// Fuzzy matching optimization constants
const SIMILARITY_THRESHOLD: f64 = 0.8; // Early exit threshold for good matches
const MAX_FUZZY_CANDIDATES: usize = 50; // Limit search scope to avoid excessive computation

/// The core orchestrator implementing the MCP tools.
#[derive(Debug)]
pub struct Toolbox {
    server: RwLock<Option<Arc<RaServer>>>,
    project_name: RwLock<Option<String>>,
    // Cache mapping generated fix_id -> WorkspaceEdit, generated by get_code_actions
    fix_cache: Arc<DashMap<String, CachedFix>>, // fix_id -> CachedFix
    // Cache for cargo check diagnostics, populated by list_diagnostics
    diagnostics_cache: Arc<DashMap<String, Vec<MyDiagnostic>>>, // project_name -> Vec<MyDiagnostic>
    request_timeout: Duration,
    shutdown_timeout: Duration,
    initial_wait: Duration,
}
impl Default for Toolbox {
    fn default() -> Self {
        Self::new()
    }
}

impl Toolbox {
    pub fn new() -> Self {
        Self {
            server: RwLock::new(None),
            project_name: RwLock::new(None),
            fix_cache: Arc::new(DashMap::new()),
            diagnostics_cache: Arc::new(DashMap::new()),
            request_timeout: Duration::from_secs(120),
            shutdown_timeout: Duration::from_secs(30),
            initial_wait: Duration::from_secs(90),
        }
    }

    pub fn with_timeouts(request_timeout: u64, shutdown_timeout: u64, initial_wait: u64) -> Self {
        Self {
            server: RwLock::new(None),
            project_name: RwLock::new(None),
            fix_cache: Arc::new(DashMap::new()),
            diagnostics_cache: Arc::new(DashMap::new()),
            request_timeout: Duration::from_secs(request_timeout).max(Duration::from_secs(10)),
            shutdown_timeout: Duration::from_secs(shutdown_timeout).max(Duration::from_secs(5)),
            initial_wait: Duration::from_secs(initial_wait).max(Duration::from_secs(5)),
        }
    }

    /// Initialize the project with a single server
    pub async fn initialize_project(&self, name: String, path: PathBuf) -> ToolResult<()> {
        // Check if a project is already initialized
        if self.server.read().await.is_some() {
            return Err(ToolboxError::ProjectAlreadyExists(name));
        }
        // Validate path first
        if !path.join("Cargo.toml").exists() {
            return Err(ToolboxError::NotACargoProject(path));
        }

        info!("Starting server for '{}' at {:?}", name, path);
        let server = RaServer::start_with_timeouts(
            &path,
            name.clone(),
            self.request_timeout,
            self.shutdown_timeout,
            self.initial_wait,
        )
        .await
        .map_err(ToolboxError::ServerError)?;
        debug!("Server for '{}' successfully started", name);
        *self.server.write().await = Some(server);
        debug!("Server instance set for project '{}'", name);
        *self.project_name.write().await = Some(name.clone());
        debug!("Project name set to '{}'", name);
        info!("Server for '{}' initialized and ready.", name);
        Ok(())
    }

    /// Wait for initial indexing to complete
    pub async fn wait_for_indexing_complete(&self) -> ToolResult<()> {
        let server = self.server.read().await;
        if let Some(server) = server.as_ref() {
            server
                .wait_for_indexing_complete()
                .await
                .map_err(ToolboxError::ServerError)?;
            Ok(())
        } else {
            Err(ToolboxError::NoActiveProject)
        }
    }

    /// Shutdown the current project
    pub async fn shutdown_project(&self) -> ToolResult<String> {
        let server_opt = self.server.write().await.take();
        let name_opt = self.project_name.write().await.take();

        if let (Some(server), Some(name)) = (server_opt, name_opt) {
            info!("Shutting down server for '{}'", name);
            server.shutdown().await.map_err(ToolboxError::ServerError)?;
            self.clear_all_cache_for_project(&name);
            info!("Server for '{}' shutdown.", name);
            Ok(format!("Successfully shutdown project '{}'", name))
        } else {
            Err(ToolboxError::NoActiveProject)
        }
    }

    /// Get current project information
    pub async fn get_project_info(&self) -> ToolResult<String> {
        let server_guard = self.server.read().await;
        let name_guard = self.project_name.read().await;

        if let (Some(server), Some(name)) = (server_guard.as_ref(), name_guard.as_ref()) {
            Ok(format!(
                "Current project: {}\nPath: {}\n",
                name,
                server.root_path().display()
            ))
        } else {
            Ok("No project initialized. Use `initialize_project` to load a project.\n".to_string())
        }
    }
    // --- Internal Helpers ---

    async fn get_active_server(&self) -> ToolResult<(String, Arc<RaServer>)> {
        let server_guard = self.server.read().await;
        let name_guard = self.project_name.read().await;

        if let (Some(server), Some(name)) = (server_guard.as_ref(), name_guard.as_ref()) {
            Ok((name.clone(), server.clone()))
        } else {
            Err(ToolboxError::NoActiveProject)
        }
    }

    fn get_relative_path(&self, server: &RaServer, absolute_path: &Path) -> String {
        // This is CPU-bound, but usually fast
        diff_paths(absolute_path, server.root_path())
            .unwrap_or_else(|| absolute_path.to_path_buf()) // Fallback
            .display()
            .to_string()
    }

    async fn validate_and_resolve_path(
        &self,
        relative_path_str: &str,
    ) -> ToolResult<(Arc<RaServer>, PathBuf, String)> {
        let (_, server) = self.get_active_server().await?;
        // clean is not blocking
        let root = server.root_path().clean();
        let proposed_path = root.join(relative_path_str).clean();

        let path_exists = tokio::fs::try_exists(&proposed_path).await.unwrap_or(false);
        let absolute = if path_exists {
            tokio::fs::canonicalize(&proposed_path)
                .await
                .unwrap_or_else(|_| proposed_path.clone())
        } else {
            proposed_path.clone()
        };

        // Security & Correctness: Must exist and be strictly within project root
        // Use absolute path for starts_with check after canonicalization
        if !path_exists || !absolute.starts_with(&root) {
            warn!(
                "Invalid, non-existent or out-of-bounds path access attempt: root={:?}, requested='{}', resolved={:?}",
                root, relative_path_str, absolute
            );
            return Err(ToolboxError::InvalidPath(PathBuf::from(relative_path_str)));
        }
        // Return the potentially canonicalized path
        Ok((server, absolute, relative_path_str.to_string()))
    }

    // Clears both fix and diagnostic cache for a project.
    // This is fast, no need for spawn_blocking
    fn clear_all_cache_for_project(&self, project_name: &str) {
        let initial_fix_count = self.fix_cache.len();

        // Optimized batch removal for fix cache
        let keys_to_remove: Vec<_> = self
            .fix_cache
            .par_iter()
            .filter_map(|entry| {
                if entry.value().project_name == project_name {
                    Some(entry.key().clone())
                } else {
                    None
                }
            })
            .collect();

        // Remove collected keys
        for key in keys_to_remove {
            self.fix_cache.remove(&key);
        }

        let final_fix_count = self.fix_cache.len();
        if initial_fix_count > final_fix_count {
            debug!(
                "Cleared {} cached fixes for project '{}'",
                initial_fix_count - final_fix_count,
                project_name
            );
        }

        // Direct removal for diagnostics cache
        if self.diagnostics_cache.remove(project_name).is_some() {
            debug!("Cleared cached diagnostics for project '{}'", project_name);
        }
    }

    // Helper to run cargo check and update cache
    async fn run_check_and_cache(
        &self,
        name: &str,
        server: Arc<RaServer>,
    ) -> ToolResult<Vec<MyDiagnostic>> {
        info!("[{}] Running external cargo check...", name);
        // Clear fixes, as new diagnostics invalidate old fixes
        self.clear_all_cache_for_project(name);

        let diags_0based: Vec<MyDiagnostic> =
            spawn_blocking(move || server.get_cargo_check_diagnostics())
                .await
                .map_err(ToolboxError::TaskJoin)? // Handle JoinError
                .map_err(ToolboxError::ServerError)?; // Handle RaError

        info!(
            "[{}] Cargo check found {} unique diagnostics.",
            name,
            diags_0based.len()
        );
        // Cache the results
        self.diagnostics_cache
            .insert(name.to_string(), diags_0based.clone());
        Ok(diags_0based)
    }

    // =======================================
    // --- MCP Tool Implementations ---
    // =======================================

    // --- list_diagnostics ---
    pub async fn list_diagnostics(
        &self,
        file_path: Option<String>,
        limit: Option<u32>,
        force_recheck: Option<bool>, // Add parameter
    ) -> ToolResult<String> {
        let (name, server) = self.get_active_server().await?;

        let force = force_recheck.unwrap_or(false);
        let all_diags =
            // Check cache first unless force is true
            if !force {
                if let Some(cached) = self.diagnostics_cache.get(&name) {
                    info!("[{}] Returning {} cached diagnostics. Use force_recheck=true to update.", name, cached.len());
                     // Clone the cached data
                    cached.value().clone()
                } else {
                    info!("[{}] No diagnostic cache found, running check.", name);
                     // run_check_and_cache uses spawn_blocking
                    self.run_check_and_cache(&name, server.clone()).await?
                }
            } else {
                info!("[{}] Force re-check requested for diagnostics.", name);
                 // run_check_and_cache uses spawn_blocking
                self.run_check_and_cache(&name, server.clone()).await?
            };
        // *********************************************************

        let limit_usize = limit.map(|l| l as usize).unwrap_or(usize::MAX);
        let resolved_path = match &file_path {
            Some(p) => Some(self.validate_and_resolve_path(p).await?.1),
            None => None,
        };

        // Clone the necessary data before moving into spawn_blocking
        let server_clone = server.clone();
        // Pre-compute relative paths for all diagnostics to avoid using self in spawn_blocking
        let diags_with_rel_paths: Vec<(MyDiagnostic, String)> = all_diags
            .iter()
            .map(|diag| {
                let rel_path = self.get_relative_path(&server_clone, &diag.location.path);
                (diag.clone(), rel_path)
            })
            .collect();

        let filtered_diags: Vec<SimpleDiagnostic> = spawn_blocking(move || {
            diags_with_rel_paths
                .iter()
                // Filter only errors and warnings first
                .filter(|&(d, _)| matches!(d.severity, MySeverity::Error | MySeverity::Warning))
                // Then filter by path if provided
                .filter(|&(d, _)| {
                    resolved_path
                        .as_ref()
                        .map_or(true, |rp| rp == &d.location.path)
                })
                .take(limit_usize)
                .map(|(diag, rel_path)| SimpleDiagnostic {
                    severity: diag.severity.to_string(),
                    message: diag.message.clone(),
                    // Use pre-computed relative path
                    file_path: rel_path.clone(),
                    // Display 1-based for user
                    line: diag.location.range.start.line + 1,
                    character: diag.location.range.start.character + 1,
                })
                .collect()
        })
        .await
        .map_err(ToolboxError::TaskJoin)?;

        let json_output = serde_json::to_string_pretty(&filtered_diags)?;
        // Add cache info to guidance
        let cache_status = if !force && self.diagnostics_cache.contains_key(&name) {
            " (from cache)"
        } else {
            " (live check)"
        };
        let guidance = if filtered_diags.is_empty() {
            format!(
                "No errors or warnings found{}. Next: Run `test_project` or explore symbols.",
                cache_status
            )
        } else {
            format!(
                "Analyze the diagnostics{}. Next: Use `get_code_actions` with a file_path and message to find fixes, or `get_symbol_info` to understand the code at the error location. Use `force_recheck: true` to get fresh results.",
                cache_status
            )
        };
        Ok(format!(
            "{}

---
Next Step: {}",
            json_output, guidance
        ))
    }

    // --- get_code_actions ---
    pub async fn get_code_actions(
        &self,
        file_path: String,
        // Allow finding by line/col as alternative to message
        diagnostic_message: Option<String>,
        line: Option<u32>,
        character: Option<u32>,
    ) -> ToolResult<String> {
        let (name, server) = self.get_active_server().await?;
        let (_, abs_path, _) = self.validate_and_resolve_path(&file_path).await?;

        // Determine the range for the code action request
        let target_range: crate::models::Range;

        if let Some(msg) = diagnostic_message {
            // Find range from cached diagnostic message
            let cached_diags = self
                .diagnostics_cache
                .get(&name)
                .ok_or_else(|| ToolboxError::CacheEmpty(name.clone()))?;

            // Try exact match first
            let exact_match = cached_diags
                .iter()
                .find(|d| d.location.path == abs_path && d.message == msg);

            let target_diag = match exact_match {
                Some(diag) => diag,
                None => {
                    // Fuzzy matching: find most similar message
                    let candidates: Vec<_> = cached_diags
                        .par_iter()
                        .filter(|d| d.location.path == abs_path)
                        .collect();

                    if candidates.is_empty() {
                        return Err(ToolboxError::DiagnosticNotFound(
                            file_path.clone(),
                            msg.clone(),
                        ));
                    }

                    // Calculate similarity scores and find best match with optimizations
                    let first_candidate = candidates[0];
                    let first_score = jaro_winkler(&first_candidate.message, &msg);

                    let (best_match, best_score, searched_count) =
                        if first_score >= SIMILARITY_THRESHOLD {
                            // First candidate is good enough, use it directly
                            (first_candidate, first_score, 1usize)
                        } else {
                            // Need to search more candidates using parallel processing
                            let search_limit = candidates.len().min(MAX_FUZZY_CANDIDATES);

                            let best_result = candidates
                                .par_iter()
                                .take(search_limit)
                                .enumerate()
                                .map(|(idx, candidate)| {
                                    let score = jaro_winkler(&candidate.message, &msg);
                                    (*candidate, score, idx + 1)
                                })
                                .reduce(
                                    || (first_candidate, first_score, 1usize),
                                    |acc, current| {
                                        if current.1 > acc.1 { current } else { acc }
                                    },
                                );

                            (best_result.0, best_result.1, search_limit)
                        };

                    // Log warning about fuzzy match
                    warn!(
                        "[{}] Using fuzzy match for diagnostic in {} (score={:.2}, searched {} candidates):\nRequested: '{}'\nFound:    '{}'",
                        name, file_path, best_score, searched_count, msg, best_match.message
                    );

                    // Return fuzzy match result
                    best_match
                }
            };

            target_range = target_diag.location.range.into();
            info!(
                "[{}] Querying code actions for diagnostic in {}",
                name, file_path
            );
        } else if let (Some(l), Some(c)) = (line, character) {
            // Use provided line/col (0-based internally)
            let pos = crate::models::Position {
                line: l.saturating_sub(1),
                character: c,
            };
            // Create a zero-width range at the position
            target_range = crate::models::Range {
                start: pos,
                end: pos,
            };
            info!(
                "[{}] Querying code actions for position {}:{} in {}",
                name, l, c, file_path
            );
        } else {
            return Err(ToolboxError::Other(
                "Provide either 'diagnostic_message' OR 'line' and 'character' for get_code_actions."
                    .into(),
            ));
        }

        // Query RA using the location
        // This is an async LSP request
        let actions = server
            .get_code_actions(&abs_path, target_range)
            .await
            .map_err(ToolboxError::ServerError)?;

        let cache = self.fix_cache.clone();
        let name_clone = name.clone();
        let actions_with_ids: Vec<ActionWithId> = spawn_blocking(move || {
            let mut results = Vec::new();
            for action in actions {
                // Check if the action actually has an edit we can apply
                if let Some(edit) = action.edit {
                    let fix_id = Uuid::new_v4().to_string();
                    let mut diff = "[Could not generate diff]".to_string();
                    // workspace_edit_to_file_edits can block on uri_to_path
                    if let Ok(file_edits) = workspace_edit_to_file_edits(&edit) {
                        if let Some(first_edit) = file_edits.first() {
                            if let Ok(content) = std::fs::read_to_string(&first_edit.path) {
                                diff = generate_diff_preview(&content, &first_edit.edits);
                            } else {
                                debug!(
                                    "[{}] Could not read file {:?} for diff generation",
                                    name_clone, first_edit.path
                                );
                            }
                        } else if !edit.changes.as_ref().map_or(true, |c| c.is_empty())
                            || !edit.document_changes.is_none()
                        {
                            diff = "[Edit applies to multiple files or uses resource operations]"
                                .to_string();
                        } else {
                            diff = "[No file changes in this edit]".to_string();
                        }
                    }
                    // Cache the edit for potential apply_fix call
                    cache.insert(
                        fix_id.clone(),
                        CachedFix {
                            project_name: name_clone.clone(),
                            edit,
                        },
                    );
                    results.push(ActionWithId {
                        id: fix_id,
                        description: action.title,
                        diff,
                    });
                } else {
                    debug!(
                        "[{}] Skipping action without edit: {}",
                        name_clone, action.title
                    );
                }
            }
            results
        })
        .await
        .map_err(ToolboxError::TaskJoin)?;

        let json_output = serde_json::to_string_pretty(&actions_with_ids)?;
        let guidance = if actions_with_ids.is_empty() {
            "No automatic fixes found for this diagnostic/location. Next: Use `get_symbol_info` or `list_document_symbols` to understand the code and manually fix the issue."
        } else {
            "Review the available fixes and their diffs. Next: Use `apply_fix` with the chosen 'id'."
        };
        Ok(format!("{}\n\n---\nNext Step: {}", json_output, guidance))
    }

    // --- apply_fix ---
    pub async fn apply_fix(&self, fix_id: String) -> ToolResult<String> {
        let (name, server) = self.get_active_server().await?;

        // Remove from cache - if not found, error
        let cached_fix = self
            .fix_cache
            .remove(&fix_id)
            .ok_or_else(|| ToolboxError::FixNotFound(fix_id.clone()))?
            .1; // Get the value part

        // Security check
        if cached_fix.project_name != name {
            warn!(
                "[{}] Attempted to apply fix {} belonging to project {}",
                name, fix_id, cached_fix.project_name
            );
            let error = ToolboxError::FixNotFound(format!(
                "{} (belongs to project {}, not active project {})",
                fix_id, cached_fix.project_name, name
            ));
            // IMPORTANT: Put it back in cache if it wasn't for this project!
            self.fix_cache.insert(fix_id.clone(), cached_fix);
            return Err(error);
        }

        // IMPORTANT: Applying ANY fix invalidates ALL other cached fixes AND diagnostics for this project
        self.clear_all_cache_for_project(&name);

        let edit_clone = cached_fix.edit.clone();
        let file_edits = spawn_blocking(move || workspace_edit_to_file_edits(&edit_clone))
            .await
            .map_err(ToolboxError::TaskJoin)?
            .map_err(|e| ToolboxError::ApplyEditFailed(format!("Conversion error: {}", e)))?;

        info!(
            "[{}] Applying fix {} across {} files",
            name,
            fix_id,
            file_edits.len()
        );
        // Apply edits and notify server for each file
        for file_edit in file_edits {
            let path = file_edit.path.clone();
            // Relative path just for logging
            let rel_path = self.get_relative_path(&server, &path);
            let server_clone = server.clone();
            debug!("[{}] Applying edits to {}", name, rel_path);

            let new_content =
                spawn_blocking(move || apply_lsp_edits_to_file(&file_edit.path, &file_edit.edits))
                    .await
                    .map_err(ToolboxError::TaskJoin)??; // Handle JoinError and ToolResult

            // CRITICAL: Notify RA server about the file change on disk to sync VFS
            // This is an async LSP notification
            server_clone
                .notify_file_content(&path, &new_content)
                .await
                .map_err(|e| {
                    ToolboxError::ApplyEditFailed(format!(
                        "Notify RA failed for {}: {}",
                        rel_path, e
                    ))
                })?;
            sleep(Duration::from_millis(200)).await;
        }
        // Optional: trigger a save notification if client supports it
        // server.send_notification::<DidSaveTextDocument>(...).await?;

        Ok(format!(
            "Success: Applied fix '{}'. Cache cleared.\n\n---\nNext Step: Run 'list_diagnostics' with force_recheck=true to verify the fix and check for new issues, or 'test_project'.",
            fix_id
        ))
    }

    // --- list_document_symbols ---
    pub async fn list_document_symbols(&self, file_path: String) -> ToolResult<String> {
        let (name, server) = self.get_active_server().await?;
        let (_, abs_path, _) = self.validate_and_resolve_path(&file_path).await?;
        info!("[{}] Listing symbols for {}", name, file_path);

        // Async LSP request
        let symbols = server
            .list_document_symbols(&abs_path)
            .await
            .map_err(ToolboxError::ServerError)?;

        // Create a function that doesn't capture self
        let server_clone = server.clone();
        // Pre-compute the path resolver function result
        let abs_path_clone = abs_path.clone();
        let path_resolver = move |p: &Path| -> String {
            // Implement path resolution logic directly without using self
            if let Some(rel) = diff_paths(p, server_clone.root_path()) {
                rel.to_string_lossy().to_string()
            } else {
                p.to_string_lossy().to_string()
            }
        };

        let flat_symbols: Vec<FlatSymbol> = spawn_blocking(move || {
            let mut flat = Vec::new();
            flatten_document_symbols(&symbols, abs_path_clone, &mut flat, &path_resolver);
            flat
        })
        .await
        .map_err(ToolboxError::TaskJoin)?;
        // Group symbols by kind and then sort by line and character
        use std::collections::BTreeMap;
        let mut grouped_symbols: BTreeMap<String, Vec<(&str, u32, u32)>> = BTreeMap::new();

        for sym in &flat_symbols {
            grouped_symbols.entry(sym.kind.clone()).or_default().push((
                &sym.name,
                sym.line + 1,
                sym.character + 1,
            ));
        }

        // Build output string grouped by kind
        let mut output_str = format!("Symbols in file: {}\n", flat_symbols[0].file_path);
        for (kind, symbols) in grouped_symbols {
            // Sort symbols by line then character
            let mut sorted_symbols = symbols;
            sorted_symbols.sort_by_key(|(_, line, char)| (*line, *char));

            output_str.push_str(&format!("\nKind: {}\n", kind));
            for (name, line, char) in sorted_symbols {
                output_str.push_str(&format!("  {}: ({}, {})\n", name, line, char));
            }
        }

        output_str.push_str("\nNote: Numbers in parentheses are (line, character).\n");

        let guidance = "Review the symbols. Next: Use `get_symbol_info` with file_path and EITHER line/character OR symbol_name to get details.";
        Ok(format!("{}\n\n---\nNext Step: {}", output_str, guidance))
    }

    // --- get_symbol_info ---
    // *** USABILITY: Redesign parameter logic ***
    pub async fn get_symbol_info(
        &self,
        file_path: String,
        line: u32,
        character: u32,
    ) -> ToolResult<String> {
        let (_, server) = self.get_active_server().await?;
        let (_, abs_path, _) = self.validate_and_resolve_path(&file_path).await?;
        // Input position is 1-based from user, convert to 0-based
        let pos = Position {
            line: line.saturating_sub(1),
            character: character.saturating_sub(1),
        };

        // get_api_structure uses goto-definition internally, so it works whether
        // `pos` points to the definition itself (from name lookup)
        // or just a usage (from line/col lookup).
        // This calls multiple async LSP requests
        let api_info_opt = server
            .get_api_structure(&abs_path, pos)
            .await
            .map_err(ToolboxError::ServerError)?;

        let guidance = "Analyze the symbol details. Next: Use this information to understand diagnostics or plan code modifications. For methods/fields, use `get_symbol_info` on their definition.";
        match api_info_opt {
            Some(api_info) => {
                // <<< PERFORMANCE: Summary generation is fast, no blocking needed
                let summary = api_info_to_summary(&api_info);
                Ok(format!(
                    "{}

---
Next Step: {}",
                    summary, guidance
                ))
            }
            None => Ok(format!(
                // Message reflects uncertainty of input method
                "Info: No detailed symbol information or definition found for the symbol at {}:{}:{}.\n\n---\nNext Step: {}",
                file_path,
                // Display 1-based
                line,
                character,
                guidance
            )),
        }
    }
    // ******************************************

    // --- search_workspace_symbols ---
    pub async fn search_workspace_symbols(&self, query: String) -> ToolResult<String> {
        let (name, server) = self.get_active_server().await?;
        info!("[{}] Searching workspace symbols for '{}'", name, query);
        if query.trim().is_empty() {
            return Err(ToolboxError::Other("Search query cannot be empty".into()));
        }

        // Async LSP request
        let symbols_response = server
            .search_workspace_symbols(&query)
            .await
            .map_err(ToolboxError::ServerError)?;

        // This block also uses rayon internally via workspace_symbols_to_flat_optimized.
        let root_path = server.root_path().to_path_buf();
        let flat_symbols = spawn_blocking(move || {
            let symbols: Vec<SymbolInformation> = match symbols_response {
                Some(WorkspaceSymbolResponse::Flat(symbols)) => symbols,
                // Convert Nested WorkspaceSymbol to Flat SymbolInformation
                Some(WorkspaceSymbolResponse::Nested(workspace_symbols)) => {
                    workspace_symbols
                        .into_par_iter()
                        .map(|ws| {
                            let location = match ws.location {
                                OneOf::Left(location) => location,
                                OneOf::Right(workspace_location) => {
                                    // Convert WorkspaceLocation to Location with empty range
                                    Location {
                                        uri: workspace_location.uri,
                                        // Use a dummy range 0:0
                                        range: Range {
                                            start: lsp_types::Position {
                                                line: 0,
                                                character: 0,
                                            },
                                            end: lsp_types::Position {
                                                line: 0,
                                                character: 0,
                                            },
                                        },
                                    }
                                }
                            };
                            SymbolInformation {
                                name: ws.name,
                                kind: ws.kind,
                                tags: ws.tags,
                                #[allow(deprecated)]
                                deprecated: None,
                                location,
                                container_name: ws.container_name,
                            }
                        })
                        .collect()
                }
                None => Vec::new(),
            };
            workspace_symbols_to_flat_optimized(&symbols, &root_path)
                .map_err(|e| ToolboxError::Other(format!("Symbol conversion error: {}", e)))
        })
        .await
        .map_err(ToolboxError::TaskJoin)??; // Handle JoinError and ToolResult

        // Group symbols by file path first, then by kind
        use std::collections::BTreeMap;
        let mut grouped_by_file: BTreeMap<String, BTreeMap<String, Vec<String>>> = BTreeMap::new();

        for sym in &flat_symbols {
            let entry = if sym.line == 0 && sym.character == 0 {
                // Dummy range, just show the file path
                format!("{}", sym.file_path)
            } else {
                // Normal symbol with valid range
                format!("{}: ({}, {})", sym.name, sym.line + 1, sym.character + 1)
            };

            grouped_by_file
                .entry(sym.file_path.clone())
                .or_default()
                .entry(sym.kind.clone())
                .or_default()
                .push(entry);
        }

        // Build output string grouped by file path
        let mut output_str = "Workspace symbol search results:\n".to_string();
        for (file_path, kinds) in grouped_by_file {
            output_str.push_str(&format!("\nFile: {}\n", file_path));
            for (kind, symbols) in kinds {
                output_str.push_str(&format!("  Kind: {}\n", kind));
                for symbol in symbols {
                    output_str.push_str(&format!("    {}\n", symbol));
                }
            }
        }

        let guidance = "Review the search results. Next: Use `get_symbol_info` with file_path and EITHER line/character OR symbol_name to get details.";
        Ok(format!("{}\n\n---\nNext Step: {}", output_str, guidance))
    }

    // --- test_project ---
    pub async fn test_project(&self, test_name: Option<String>) -> ToolResult<String> {
        let (name, server) = self.get_active_server().await?;
        info!("[{}] Running tests (filter: {:?})...", name, test_name);
        // Tests might change state or rely on diagnostics, clear cache.
        self.clear_all_cache_for_project(&name);

        let server_clone = server.clone();
        let output: CargoTestOutput =
            spawn_blocking(move || server_clone.run_cargo_test(test_name.as_deref()))
                .await
                .map_err(ToolboxError::TaskJoin)??; // Handle JoinError and ToolResult

        let guidance = if output.success {
            info!("[{}] Tests passed.", name);
            "All tests passed. The task is likely complete."
        } else {
            warn!("[{}] Tests failed.", name);
            "Tests failed. Analyze the output. Use `list_diagnostics` (with force_recheck=true), `get_symbol_info`, or client-side file reading to understand the issue, then fix using `apply_fix` or manual edits."
        };
        // Combine output for failures
        let report = if output.success {
            format!("--- STDOUT ---\n{}", output.stdout)
        } else {
            format!(
                "--- STDOUT ---\n{}\n--- STDERR ---\n{}",
                output.stdout, output.stderr
            )
        };
        Ok(format!("{}\n\n---\nNext Step: {}", report, guidance))
    }

    /// Gracefully shuts down the managed server instance.
    pub async fn shutdown_all(&self) -> ToolResult<()> {
        info!("Toolbox shutting down server...");

        let server_opt = self.server.write().await.take();
        let name_opt = self.project_name.write().await.take();

        if let (Some(server), Some(name)) = (server_opt, name_opt) {
            info!("Shutting down server for project '{}'...", name);
            if let Err(e) = server.shutdown().await {
                error!("Error shutting down server for project '{}': {}", name, e);
            }
            self.clear_all_cache_for_project(&name);
        }

        self.fix_cache.clear();
        self.diagnostics_cache.clear();
        info!("Toolbox shutdown complete.");
        Ok(())
    }
}
